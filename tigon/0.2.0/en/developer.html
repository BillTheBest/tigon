<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <script type="text/javascript">

      var _gaq = _gaq || [];
      _gaq.push(['_setAccount', 'UA-55081520-4']);
      _gaq.push(['_trackPageview']);

      (function() {
        var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
        ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
        var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
      })();
    </script>
    <title>Tigon Developer Guide &mdash; Tigon 0.2.0 Documentation</title>
    
    <link rel="stylesheet" href="_static/tigon.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '0.2.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  false
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <link rel="shortcut icon" href="_static/favicon.ico"/>
    <link rel="top" title="Tigon 0.2.0 Documentation" href="index.html" />
    <link rel="next" title="Tigon Examples and Reference Applications" href="examples/index.html" />
    <link rel="prev" title="Tigon Concepts and Architecture" href="concepts.html" /> 
  </head>
  <body role="document">
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">Index</a></li>
        <li class="right" >
          <a href="examples/index.html" title="Tigon Examples and Reference Applications"
             accesskey="N">Next</a> |</li>
        <li class="right" >
          <a href="concepts.html" title="Tigon Concepts and Architecture"
             accesskey="P">Previous</a> |</li>
        <li><a href="table-of-contents.html">Tigon 0.2.0 Documentation</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="tigon-developer-guide">
<h1>Tigon Developer Guide<a class="headerlink" href="#tigon-developer-guide" title="Permalink to this headline">¶</a></h1>
<div class="section" id="tigon-flows">
<h2>Tigon Flows<a class="headerlink" href="#tigon-flows" title="Permalink to this headline">¶</a></h2>
<p><strong>Flows</strong> are developer-implemented, real-time stream processors. They
are comprised of one or more <a class="reference internal" href="#flowlets">Flowlets</a> that are wired together into a
directed acyclic graph or DAG.</p>
<p>Flowlets pass DataObjects between one another. Each Flowlet is able to
perform custom logic and execute data operations for each individual
data object processed. All data operations happen in a consistent and
durable way.</p>
<p>When processing a single input object, all operations, including the
removal of the object from the input, and emission of data to the
outputs, are executed in a transaction. This provides us with Atomicity,
Consistency, Isolation, and Durability (ACID) properties, and helps
assure a unique and core property of the Flow system: it guarantees
atomic and &#8220;exactly-once&#8221; processing of each input object by each
Flowlet in the DAG.</p>
<p>A Flow runs as a YARN application and each Flowlet instance runs in its own container.
Each Flowlet in the DAG can have multiple concurrent instances, each consuming a partition
of the Flowlet’s inputs.</p>
<p>To put data into your Flow, you implement a Flowlet to generate or pull the data
from an external source.</p>
<p>The <tt class="docutils literal"><span class="pre">Flow</span></tt> interface allows you to specify the Flow’s metadata, <a class="reference internal" href="#flowlets">Flowlets</a>, and
<a class="reference external" href="#connection">Flowlet connections</a>.</p>
<p>To create a Flow, implement <tt class="docutils literal"><span class="pre">Flow</span></tt> via a <tt class="docutils literal"><span class="pre">configure</span></tt> method that
returns a <tt class="docutils literal"><span class="pre">FlowSpecification</span></tt> using <tt class="docutils literal"><span class="pre">FlowSpecification.Builder()</span></tt>:</p>
<div class="highlight-java"><div class="highlight"><pre><span class="kd">class</span> <span class="nc">MyExampleFlow</span> <span class="kd">implements</span> <span class="n">Flow</span> <span class="o">{</span>
  <span class="nd">@Override</span>
  <span class="kd">public</span> <span class="n">FlowSpecification</span> <span class="nf">configure</span><span class="o">()</span> <span class="o">{</span>
    <span class="k">return</span> <span class="n">FlowSpecification</span><span class="o">.</span><span class="na">Builder</span><span class="o">.</span><span class="na">with</span><span class="o">()</span>
      <span class="o">.</span><span class="na">setName</span><span class="o">(</span><span class="s">&quot;mySampleFlow&quot;</span><span class="o">)</span>
      <span class="o">.</span><span class="na">setDescription</span><span class="o">(</span><span class="s">&quot;Flow for showing examples&quot;</span><span class="o">)</span>
      <span class="o">.</span><span class="na">withFlowlets</span><span class="o">()</span>
        <span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="s">&quot;flowlet1&quot;</span><span class="o">,</span> <span class="k">new</span> <span class="n">MyExampleFlowlet</span><span class="o">(),</span> <span class="mi">1</span><span class="o">)</span>
        <span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="s">&quot;flowlet2&quot;</span><span class="o">,</span> <span class="k">new</span> <span class="n">MyExampleFlowlet2</span><span class="o">(),</span> <span class="mi">3</span><span class="o">)</span>
      <span class="o">.</span><span class="na">connect</span><span class="o">()</span>
        <span class="o">.</span><span class="na">from</span><span class="o">(</span><span class="s">&quot;flowlet1&quot;</span><span class="o">).</span><span class="na">to</span><span class="o">(</span><span class="s">&quot;flowlet2&quot;</span><span class="o">)</span>
      <span class="o">.</span><span class="na">build</span><span class="o">();</span>
<span class="o">}</span>
</pre></div>
</div>
<p>In this example, the <em>name</em>, <em>description</em>, <em>with</em> (or <em>without</em>) Flowlets, and
<em>connections</em> are specified before building the Flow. The code above creates a Flow with
two Flowlets; the first named <em>flowlet1</em>, a <tt class="docutils literal"><span class="pre">MyExampleFlowlet</span></tt> with 1 instance, and the
second <em>flowlet2</em>, a <tt class="docutils literal"><span class="pre">MyExampleFlowlet2</span></tt> with 3 instances.</p>
</div>
<div class="section" id="tigon-flowlets">
<span id="flowlets"></span><h2>Tigon Flowlets<a class="headerlink" href="#tigon-flowlets" title="Permalink to this headline">¶</a></h2>
<p><strong>Flowlets</strong>, the basic building blocks of a Flow, represent each
individual processing node within a Flow. Flowlets consume data objects
from their inputs and execute custom logic on each data object, allowing
you to perform data operations as well as emit data objects to the
Flowlet’s outputs. Flowlets specify an <tt class="docutils literal"><span class="pre">initialize()</span></tt> method, which is
executed at the startup of each instance of a Flowlet before it receives
any data.</p>
<p>The example below shows a Flowlet that reads <em>Double</em> values, rounds
them, and emits the results. It has a simple configuration method and
doesn&#8217;t do anything for initialization or destruction:</p>
<div class="highlight-java"><div class="highlight"><pre><span class="kd">class</span> <span class="nc">RoundingFlowlet</span> <span class="kd">implements</span> <span class="n">Flowlet</span> <span class="o">{</span>

  <span class="nd">@Override</span>
  <span class="kd">public</span> <span class="n">FlowletSpecification</span> <span class="nf">configure</span><span class="o">()</span> <span class="o">{</span>
    <span class="k">return</span> <span class="n">FlowletSpecification</span><span class="o">.</span><span class="na">Builder</span><span class="o">.</span><span class="na">with</span><span class="o">().</span>
      <span class="n">setName</span><span class="o">(</span><span class="s">&quot;round&quot;</span><span class="o">).</span>
      <span class="n">setDescription</span><span class="o">(</span><span class="s">&quot;A rounding Flowlet&quot;</span><span class="o">).</span>
      <span class="n">build</span><span class="o">();</span>
  <span class="o">}</span>

  <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">initialize</span><span class="o">(</span><span class="n">FlowletContext</span> <span class="n">context</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">Exception</span> <span class="o">{</span>
  <span class="o">}</span>

  <span class="nd">@Override</span>
  <span class="kd">public</span> <span class="kt">void</span> <span class="nf">destroy</span><span class="o">()</span> <span class="o">{</span>
  <span class="o">}</span>

  <span class="n">OutputEmitter</span><span class="o">&lt;</span><span class="n">Long</span><span class="o">&gt;</span> <span class="n">output</span><span class="o">;</span>
  <span class="nd">@ProcessInput</span>
  <span class="kd">public</span> <span class="kt">void</span> <span class="nf">round</span><span class="o">(</span><span class="n">Double</span> <span class="n">number</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">output</span><span class="o">.</span><span class="na">emit</span><span class="o">(</span><span class="n">Math</span><span class="o">.</span><span class="na">round</span><span class="o">(</span><span class="n">number</span><span class="o">));</span>
  <span class="o">}</span>
</pre></div>
</div>
<p>The most interesting method of this Flowlet is <tt class="docutils literal"><span class="pre">round()</span></tt>, the method
that does the actual processing. It uses an output emitter to send data
to its output. This is the only way that a Flowlet can emit output to
another connected Flowlet:</p>
<div class="highlight-java"><div class="highlight"><pre><span class="n">OutputEmitter</span><span class="o">&lt;</span><span class="n">Long</span><span class="o">&gt;</span> <span class="n">output</span><span class="o">;</span>
<span class="nd">@ProcessInput</span>
<span class="kd">public</span> <span class="kt">void</span> <span class="nf">round</span><span class="o">(</span><span class="n">Double</span> <span class="n">number</span><span class="o">)</span> <span class="o">{</span>
  <span class="n">output</span><span class="o">.</span><span class="na">emit</span><span class="o">(</span><span class="n">Math</span><span class="o">.</span><span class="na">round</span><span class="o">(</span><span class="n">number</span><span class="o">));</span>
<span class="o">}</span>
</pre></div>
</div>
<p>Note that the Flowlet declares the output emitter but does not
initialize it. The Flow system initializes and injects its
implementation at runtime.</p>
<p>The method is annotated with <tt class="docutils literal"><span class="pre">&#64;ProcessInput</span></tt>—this tells the Flow
system that this method can process input data.</p>
<p>You can overload the process method of a Flowlet by adding multiple
methods with different input types. When an input object comes in, the
Flowlet will call the method that matches the object’s type:</p>
<div class="highlight-java"><div class="highlight"><pre><span class="n">OutputEmitter</span><span class="o">&lt;</span><span class="n">Long</span><span class="o">&gt;</span> <span class="n">output</span><span class="o">;</span>

<span class="nd">@ProcessInput</span>
<span class="kd">public</span> <span class="kt">void</span> <span class="nf">round</span><span class="o">(</span><span class="n">Double</span> <span class="n">number</span><span class="o">)</span> <span class="o">{</span>
  <span class="n">output</span><span class="o">.</span><span class="na">emit</span><span class="o">(</span><span class="n">Math</span><span class="o">.</span><span class="na">round</span><span class="o">(</span><span class="n">number</span><span class="o">));</span>
<span class="o">}</span>
<span class="nd">@ProcessInput</span>
<span class="kd">public</span> <span class="kt">void</span> <span class="nf">round</span><span class="o">(</span><span class="n">Float</span> <span class="n">number</span><span class="o">)</span> <span class="o">{</span>
  <span class="n">output</span><span class="o">.</span><span class="na">emit</span><span class="o">((</span><span class="kt">long</span><span class="o">)</span><span class="n">Math</span><span class="o">.</span><span class="na">round</span><span class="o">(</span><span class="n">number</span><span class="o">));</span>
<span class="o">}</span>
</pre></div>
</div>
<p>If you define multiple process methods, a method will be selected based
on the input object’s origin; that is, the name of a Stream or the name
of an output of a Flowlet.</p>
<p>A Flowlet that emits data can specify this name using an annotation on
the output emitter. In the absence of this annotation, the name of the
output defaults to “out”:</p>
<div class="highlight-java"><div class="highlight"><pre><span class="nd">@Output</span><span class="o">(</span><span class="s">&quot;code&quot;</span><span class="o">)</span>
<span class="n">OutputEmitter</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">out</span><span class="o">;</span>
</pre></div>
</div>
<p>Data objects emitted through this output can then be directed to a
process method of a receiving Flowlet by annotating the method with the
origin name:</p>
<div class="highlight-java"><div class="highlight"><pre><span class="nd">@ProcessInput</span><span class="o">(</span><span class="s">&quot;code&quot;</span><span class="o">)</span>
<span class="kd">public</span> <span class="kt">void</span> <span class="nf">tokenizeCode</span><span class="o">(</span><span class="n">String</span> <span class="n">text</span><span class="o">)</span> <span class="o">{</span>
  <span class="o">...</span> <span class="c1">// perform fancy code tokenization</span>
<span class="o">}</span>
</pre></div>
</div>
<div class="section" id="input-context">
<h3>Input Context<a class="headerlink" href="#input-context" title="Permalink to this headline">¶</a></h3>
<p>A process method can have an additional parameter, the <tt class="docutils literal"><span class="pre">InputContext</span></tt>.
The input context provides information about the input object, such as
its origin and the number of times the object has been retried. For
example, this Flowlet tokenizes text in a smart way and uses the input
context to decide which tokenizer to use:</p>
<div class="highlight-java"><div class="highlight"><pre><span class="nd">@ProcessInput</span>
<span class="kd">public</span> <span class="kt">void</span> <span class="nf">tokenize</span><span class="o">(</span><span class="n">String</span> <span class="n">text</span><span class="o">,</span> <span class="n">InputContext</span> <span class="n">context</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">Exception</span> <span class="o">{</span>
  <span class="n">Tokenizer</span> <span class="n">tokenizer</span><span class="o">;</span>
  <span class="c1">// If this failed before, fall back to simple white space</span>
  <span class="k">if</span> <span class="o">(</span><span class="n">context</span><span class="o">.</span><span class="na">getRetryCount</span><span class="o">()</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">tokenizer</span> <span class="o">=</span> <span class="k">new</span> <span class="n">WhiteSpaceTokenizer</span><span class="o">();</span>
  <span class="o">}</span>
  <span class="c1">// Is this code? If its origin is named &quot;code&quot;, then assume yes</span>
  <span class="k">else</span> <span class="nf">if</span> <span class="o">(</span><span class="s">&quot;code&quot;</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="n">context</span><span class="o">.</span><span class="na">getOrigin</span><span class="o">()))</span> <span class="o">{</span>
    <span class="n">tokenizer</span> <span class="o">=</span> <span class="k">new</span> <span class="n">CodeTokenizer</span><span class="o">();</span>
  <span class="o">}</span>
  <span class="k">else</span> <span class="o">{</span>
    <span class="c1">// Use the smarter tokenizer</span>
    <span class="n">tokenizer</span> <span class="o">=</span> <span class="k">new</span> <span class="n">NaturalLanguageTokenizer</span><span class="o">();</span>
  <span class="o">}</span>
  <span class="k">for</span> <span class="o">(</span><span class="n">String</span> <span class="n">token</span> <span class="o">:</span> <span class="n">tokenizer</span><span class="o">.</span><span class="na">tokenize</span><span class="o">(</span><span class="n">text</span><span class="o">))</span> <span class="o">{</span>
    <span class="n">output</span><span class="o">.</span><span class="na">emit</span><span class="o">(</span><span class="n">token</span><span class="o">);</span>
  <span class="o">}</span>
<span class="o">}</span>
</pre></div>
</div>
</div>
<div class="section" id="type-projection">
<h3>Type Projection<a class="headerlink" href="#type-projection" title="Permalink to this headline">¶</a></h3>
<p>Flowlets perform an implicit projection on the input objects if they do
not match exactly what the process method accepts as arguments. This
allows you to write a single process method that can accept multiple
<strong>compatible</strong> types. For example, if you have a process method:</p>
<div class="highlight-java"><div class="highlight"><pre><span class="nd">@ProcessInput</span>
<span class="n">count</span><span class="o">(</span><span class="n">String</span> <span class="n">word</span><span class="o">)</span> <span class="o">{</span>
  <span class="o">...</span>
<span class="o">}</span>
</pre></div>
</div>
<p>and you send data of type <tt class="docutils literal"><span class="pre">Long</span></tt> to this Flowlet, then that type does
not exactly match what the process method expects. You could now write
another process method for <tt class="docutils literal"><span class="pre">Long</span></tt> numbers:</p>
<div class="highlight-java"><div class="highlight"><pre><span class="nd">@ProcessInput</span> <span class="n">count</span><span class="o">(</span><span class="n">Long</span> <span class="n">number</span><span class="o">)</span> <span class="o">{</span>
  <span class="n">count</span><span class="o">(</span><span class="n">number</span><span class="o">.</span><span class="na">toString</span><span class="o">());</span>
<span class="o">}</span>
</pre></div>
</div>
<p>and you could do that for every type that you might possibly want to
count, but that would be rather tedious. Type projection does this for
you automatically. If no process method is found that matches the type
of an object exactly, it picks a method that is compatible with the
object.</p>
<p>In this case, because Long can be converted into a String, it is
compatible with the original process method. Other compatible
conversions are:</p>
<ul>
<li><p class="first">Every primitive type that can be converted to a <tt class="docutils literal"><span class="pre">String</span></tt> is compatible with
<tt class="docutils literal"><span class="pre">String</span></tt>.</p>
</li>
<li><p class="first">Any numeric type is compatible with numeric types that can represent it.
For example, <tt class="docutils literal"><span class="pre">int</span></tt> is compatible with <tt class="docutils literal"><span class="pre">long</span></tt>, <tt class="docutils literal"><span class="pre">float</span></tt> and <tt class="docutils literal"><span class="pre">double</span></tt>,
and <tt class="docutils literal"><span class="pre">long</span></tt> is compatible with <tt class="docutils literal"><span class="pre">float</span></tt> and <tt class="docutils literal"><span class="pre">double</span></tt>, but <tt class="docutils literal"><span class="pre">long</span></tt> is not
compatible with <tt class="docutils literal"><span class="pre">int</span></tt> because <tt class="docutils literal"><span class="pre">int</span></tt> cannot represent every <tt class="docutils literal"><span class="pre">long</span></tt> value.</p>
</li>
<li><p class="first">A byte array is compatible with a <tt class="docutils literal"><span class="pre">ByteBuffer</span></tt> and vice versa.</p>
</li>
<li><p class="first">A collection of type A is compatible with a collection of type B,
if type A is compatible with type B.
Here, a collection can be an array or any Java <tt class="docutils literal"><span class="pre">Collection</span></tt>.
Hence, a <tt class="docutils literal"><span class="pre">List&lt;Integer&gt;</span></tt> is compatible with a <tt class="docutils literal"><span class="pre">String[]</span></tt> array.</p>
</li>
<li><p class="first">Two maps are compatible if their underlying types are compatible.
For example, a <tt class="docutils literal"><span class="pre">TreeMap&lt;Integer,</span> <span class="pre">Boolean&gt;</span></tt> is compatible with a
<tt class="docutils literal"><span class="pre">HashMap&lt;String,</span> <span class="pre">String&gt;</span></tt>.</p>
</li>
<li><p class="first">Other Java objects can be compatible if their fields are compatible.
For example, in the following class <tt class="docutils literal"><span class="pre">Point</span></tt> is compatible with <tt class="docutils literal"><span class="pre">Coordinate</span></tt>,
because all common fields between the two classes are compatible.
When projecting from <tt class="docutils literal"><span class="pre">Point</span></tt> to <tt class="docutils literal"><span class="pre">Coordinate</span></tt>, the color field is dropped,
whereas the projection from <tt class="docutils literal"><span class="pre">Coordinate</span></tt> to <tt class="docutils literal"><span class="pre">Point</span></tt> will leave the <tt class="docutils literal"><span class="pre">color</span></tt> field
as <tt class="docutils literal"><span class="pre">null</span></tt>:</p>
<div class="highlight-java"><div class="highlight"><pre><span class="kd">class</span> <span class="nc">Point</span> <span class="o">{</span>
  <span class="kd">private</span> <span class="kt">int</span> <span class="n">x</span><span class="o">;</span>
  <span class="kd">private</span> <span class="kt">int</span> <span class="n">y</span><span class="o">;</span>
  <span class="kd">private</span> <span class="n">String</span> <span class="n">color</span><span class="o">;</span>
<span class="o">}</span>

<span class="kd">class</span> <span class="nc">Coordinates</span> <span class="o">{</span>
  <span class="kt">int</span> <span class="n">x</span><span class="o">;</span>
  <span class="kt">int</span> <span class="n">y</span><span class="o">;</span>
<span class="o">}</span>
</pre></div>
</div>
</li>
</ul>
<p>Type projections help you keep your code generic and reusable. They also
interact well with inheritance. If a Flowlet can process a specific
object class, then it can also process any subclass of that class.</p>
</div>
<div class="section" id="flowlet-method-and-tick-annotation">
<h3>Flowlet Method and &#64;Tick Annotation<a class="headerlink" href="#flowlet-method-and-tick-annotation" title="Permalink to this headline">¶</a></h3>
<p>A Flowlet’s method can be annotated with <tt class="docutils literal"><span class="pre">&#64;Tick</span></tt>. Instead of
processing data objects from a Flowlet input, this method is invoked
periodically, without arguments. This can be used, for example, to
generate data, or pull data from an external data source periodically on
a fixed cadence.</p>
<p>In this code snippet from the <em>CountRandom</em> example, the <tt class="docutils literal"><span class="pre">&#64;Tick</span></tt>
method in the Flowlet emits random numbers:</p>
<div class="highlight-java"><div class="highlight"><pre><span class="kd">public</span> <span class="kd">class</span> <span class="nc">RandomSource</span> <span class="kd">extends</span> <span class="n">AbstractFlowlet</span> <span class="o">{</span>

  <span class="kd">private</span> <span class="n">OutputEmitter</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">randomOutput</span><span class="o">;</span>

  <span class="kd">private</span> <span class="kd">final</span> <span class="n">Random</span> <span class="n">random</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Random</span><span class="o">();</span>

  <span class="nd">@Tick</span><span class="o">(</span><span class="n">delay</span> <span class="o">=</span> <span class="mi">1L</span><span class="o">,</span> <span class="n">unit</span> <span class="o">=</span> <span class="n">TimeUnit</span><span class="o">.</span><span class="na">MILLISECONDS</span><span class="o">)</span>
  <span class="kd">public</span> <span class="kt">void</span> <span class="nf">generate</span><span class="o">()</span> <span class="kd">throws</span> <span class="n">InterruptedException</span> <span class="o">{</span>
    <span class="n">randomOutput</span><span class="o">.</span><span class="na">emit</span><span class="o">(</span><span class="n">random</span><span class="o">.</span><span class="na">nextInt</span><span class="o">(</span><span class="mi">10000</span><span class="o">));</span>
  <span class="o">}</span>
<span class="o">}</span>
</pre></div>
</div>
<p>Note: &#64;Tick method calls are serialized; subsequent calls to the tick
method will be made only after the previous &#64;Tick method call has returned.</p>
</div>
<div class="section" id="connection">
<h3>Connection<a class="headerlink" href="#connection" title="Permalink to this headline">¶</a></h3>
<p>There are multiple ways to connect the Flowlets of a Flow. The most
common form is to use the Flowlet name. Because the name of each Flowlet
defaults to its class name, when building the Flow specification you can
simply write:</p>
<div class="highlight-java"><div class="highlight"><pre><span class="o">.</span><span class="na">withFlowlets</span><span class="o">()</span>
  <span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="k">new</span> <span class="n">RandomGenerator</span><span class="o">())</span>
  <span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="k">new</span> <span class="n">RoundingFlowlet</span><span class="o">())</span>
<span class="o">.</span><span class="na">connect</span><span class="o">()</span>
  <span class="o">.</span><span class="na">from</span><span class="o">(</span><span class="s">&quot;RandomGenerator&quot;</span><span class="o">).</span><span class="na">to</span><span class="o">(</span><span class="s">&quot;RoundingFlowlet&quot;</span><span class="o">)</span>
</pre></div>
</div>
<p>If you have multiple Flowlets of the same class, you can give them explicit names:</p>
<div class="highlight-java"><div class="highlight"><pre><span class="o">.</span><span class="na">withFlowlets</span><span class="o">()</span>
  <span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="s">&quot;random&quot;</span><span class="o">,</span> <span class="k">new</span> <span class="n">RandomGenerator</span><span class="o">())</span>
  <span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="s">&quot;generator&quot;</span><span class="o">,</span> <span class="k">new</span> <span class="n">RandomGenerator</span><span class="o">())</span>
  <span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="s">&quot;rounding&quot;</span><span class="o">,</span> <span class="k">new</span> <span class="n">RoundingFlowlet</span><span class="o">())</span>
<span class="o">.</span><span class="na">connect</span><span class="o">()</span>
  <span class="o">.</span><span class="na">from</span><span class="o">(</span><span class="s">&quot;random&quot;</span><span class="o">).</span><span class="na">to</span><span class="o">(</span><span class="s">&quot;rounding&quot;</span><span class="o">)</span>
</pre></div>
</div>
</div>
<div class="section" id="batch-execution">
<h3>Batch Execution<a class="headerlink" href="#batch-execution" title="Permalink to this headline">¶</a></h3>
<p>By default, a Flowlet processes a single data object at a time within a single
transaction. To increase throughput, you can also process a batch of data objects within
the same transaction:</p>
<div class="highlight-java"><div class="highlight"><pre><span class="nd">@Batch</span><span class="o">(</span><span class="mi">100</span><span class="o">)</span>
<span class="nd">@ProcessInput</span>
<span class="kd">public</span> <span class="kt">void</span> <span class="nf">process</span><span class="o">(</span><span class="n">String</span> <span class="n">words</span><span class="o">)</span> <span class="o">{</span>
  <span class="o">...</span>
</pre></div>
</div>
<p>For the above batch example, the <strong>process</strong> method will be called up to 100 times per
transaction, with different data objects read from the input each time it is called.</p>
<p>If you are interested in knowing when a batch begins and ends, you can use an <strong>Iterator</strong>
as the method argument:</p>
<div class="highlight-java"><div class="highlight"><pre><span class="nd">@Batch</span><span class="o">(</span><span class="mi">100</span><span class="o">)</span>
<span class="nd">@ProcessInput</span>
<span class="kd">public</span> <span class="kt">void</span> <span class="nf">process</span><span class="o">(</span><span class="n">Iterator</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">words</span><span class="o">)</span> <span class="o">{</span>
  <span class="o">...</span>
</pre></div>
</div>
<p>In this case, the <strong>process</strong> will be called once per transaction and the <strong>Iterator</strong>
will contain up to 100 data objects read from the input.</p>
</div>
<div class="section" id="flowlets-and-instances">
<h3>Flowlets and Instances<a class="headerlink" href="#flowlets-and-instances" title="Permalink to this headline">¶</a></h3>
<p>You can have one or more instances of any given Flowlet, each consuming a disjoint
partition of each input. You can control the number of instances through the
command-line interface (CLI) in Distributed Mode.. This enables you
to scale your application to meet capacity at runtime.</p>
<p>In Tigon Standalone, multiple Flowlet instances are run in threads, so in some cases
actual performance may not be improved. However, in the Tigon Distributed,
each Flowlet instance runs in its own Java Virtual Machine (JVM) with independent compute
resources. Scaling the number of Flowlets can improve performance and have a major impact
depending on your implementation.</p>
</div>
<div class="section" id="partitioning-strategies">
<h3>Partitioning Strategies<a class="headerlink" href="#partitioning-strategies" title="Permalink to this headline">¶</a></h3>
<p>As mentioned above, if you have multiple instances of a Flowlet the input queue is
partitioned among the Flowlets. The partitioning can occur in different ways, and each
Flowlet can specify one of these three partitioning strategies:</p>
<ul class="simple">
<li><strong>First-in first-out (FIFO):</strong> Default mode. In this mode, every Flowlet instance
receives the next available data object in the queue. However, since multiple consumers
may compete for the same data object, access to the queue must be synchronized. This may
not always be the most efficient strategy.</li>
<li><strong>Round-robin:</strong> With this strategy, the number of items is distributed evenly among the
instances. In general, round-robin is the most efficient partitioning. Though more
efficient than FIFO, it is not ideal when the application needs to group objects into
buckets according to business logic. In those cases, hash-based partitioning is
preferable.</li>
<li><strong>Hash-based:</strong> If the emitting Flowlet annotates each data object with a hash key, this
partitioning ensures that all objects of a given key are received by the same consumer
instance. This can be useful for aggregating by key, and can help reduce write conflicts
when writing to HBase in distributed mode.</li>
</ul>
<p>Let&#8217;s look at a case where a Hash Partition is required. Suppose we have a Flowlet that counts words:</p>
<div class="highlight-java"><div class="highlight"><pre><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Counter</span> <span class="kd">extends</span> <span class="n">AbstractFlowlet</span> <span class="o">{</span>

  <span class="kd">private</span> <span class="n">Map</span><span class="o">&lt;</span><span class="n">String</span><span class="o">,</span> <span class="n">Integer</span><span class="o">&gt;</span> <span class="n">wordCount</span> <span class="o">=</span> <span class="n">Maps</span><span class="o">.</span><span class="na">newHashMap</span><span class="o">();</span>

  <span class="nd">@ProcessInput</span><span class="o">(</span><span class="s">&quot;wordOut&quot;</span><span class="o">)</span>
  <span class="kd">public</span> <span class="kt">void</span> <span class="nf">process</span><span class="o">(</span><span class="n">String</span> <span class="n">word</span><span class="o">)</span> <span class="o">{</span>
    <span class="kt">int</span> <span class="n">count</span> <span class="o">=</span> <span class="n">wordCount</span><span class="o">.</span><span class="na">containsKey</span><span class="o">(</span><span class="n">word</span><span class="o">)</span> <span class="o">?</span> <span class="o">(</span><span class="n">wordCount</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">word</span><span class="o">)</span> <span class="o">+</span> <span class="mi">1</span><span class="o">)</span> <span class="o">:</span> <span class="mi">1</span><span class="o">;</span>
    <span class="n">wordCount</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">word</span><span class="o">,</span> <span class="n">count</span><span class="o">);</span>
  <span class="o">}</span>
<span class="o">}</span>
</pre></div>
</div>
<p>This Flowlet uses the default strategy of FIFO. To increase the throughput when this
Flowlet has many instances, we can specify round-robin partitioning:</p>
<div class="highlight-java"><div class="highlight"><pre><span class="nd">@RoundRobin</span>
<span class="nd">@ProcessInput</span><span class="o">(</span><span class="s">&quot;wordOut&quot;</span><span class="o">)</span>
<span class="kd">public</span> <span class="kt">void</span> <span class="nf">process</span><span class="o">(</span><span class="n">String</span> <span class="n">word</span><span class="o">)</span> <span class="o">{</span>
  <span class="kt">int</span> <span class="n">count</span> <span class="o">=</span> <span class="n">wordCount</span><span class="o">.</span><span class="na">containsKey</span><span class="o">(</span><span class="n">word</span><span class="o">)</span> <span class="o">?</span> <span class="o">(</span><span class="n">wordCount</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">word</span><span class="o">)</span> <span class="o">+</span> <span class="mi">1</span><span class="o">)</span> <span class="o">:</span> <span class="mi">1</span><span class="o">;</span>
  <span class="n">wordCount</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">word</span><span class="o">,</span> <span class="n">count</span><span class="o">);</span>
<span class="o">}</span>
</pre></div>
</div>
<p>Now, if we have three instances of this Flowlet, every instance will receive every third
word. For example, for the sequence of words in the sentence, “I scream, you scream, we
all scream for ice cream”:</p>
<ul class="simple">
<li>The first instance receives the words: <em>I scream scream cream</em></li>
<li>The second instance receives the words: <em>scream we for</em></li>
<li>The third instance receives the words: <em>you all ice</em></li>
</ul>
<p>The potential problem with this is that the first two instances might both attempt to
increment the counter for the word <em>scream</em> and thus lead to an incorrect count (since the
count is stored in-memory in different flowlets). To avoid conflicts, we can use
hash-based partitioning:</p>
<div class="highlight-java"><div class="highlight"><pre><span class="nd">@HashPartition</span><span class="o">(</span><span class="s">&quot;wordHash&quot;</span><span class="o">)</span>
<span class="nd">@ProcessInput</span><span class="o">(</span><span class="s">&quot;wordOut&quot;</span><span class="o">)</span>
<span class="kd">public</span> <span class="kt">void</span> <span class="nf">process</span><span class="o">(</span><span class="n">String</span> <span class="n">word</span><span class="o">)</span> <span class="o">{</span>
  <span class="kt">int</span> <span class="n">count</span> <span class="o">=</span> <span class="n">wordCount</span><span class="o">.</span><span class="na">containsKey</span><span class="o">(</span><span class="n">word</span><span class="o">)</span> <span class="o">?</span> <span class="o">(</span><span class="n">wordCount</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">word</span><span class="o">)</span> <span class="o">+</span> <span class="mi">1</span><span class="o">)</span> <span class="o">:</span> <span class="mi">1</span><span class="o">;</span>
  <span class="n">wordCount</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">word</span><span class="o">,</span> <span class="n">count</span><span class="o">);</span>
<span class="o">}</span>
</pre></div>
</div>
<p>Now only one of the Flowlet instances will receive the word <em>scream</em>, and there can be no
more incorrect counts. Note that in order to use hash-based partitioning, the emitting
Flowlet must annotate each data object with the partitioning key:</p>
<div class="highlight-java"><div class="highlight"><pre><span class="nd">@Output</span><span class="o">(</span><span class="s">&quot;wordOut&quot;</span><span class="o">)</span>
<span class="kd">private</span> <span class="n">OutputEmitter</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">wordOutput</span><span class="o">;</span>
<span class="o">...</span>
<span class="kd">public</span> <span class="kt">void</span> <span class="nf">process</span><span class="o">(</span><span class="n">StreamEvent</span> <span class="n">event</span><span class="o">)</span> <span class="o">{</span>
  <span class="o">...</span>
  <span class="c1">// emit the word with the partitioning key name &quot;wordHash&quot;</span>
  <span class="n">wordOutput</span><span class="o">.</span><span class="na">emit</span><span class="o">(</span><span class="n">word</span><span class="o">,</span> <span class="s">&quot;wordHash&quot;</span><span class="o">,</span> <span class="n">word</span><span class="o">.</span><span class="na">hashCode</span><span class="o">());</span>
<span class="o">}</span>
</pre></div>
</div>
<p>Note that the emitter must use the same name (&#8220;wordHash&#8221;) for the key that the consuming
Flowlet specifies as the partitioning key. If the output is connected to more than one
Flowlet, you can also annotate a data object with multiple hash keys—each consuming
Flowlet can then use different partitioning. This is useful if you want to aggregate by
multiple keys, such as counting purchases by product ID as well as by customer ID.</p>
<p>Partitioning can be combined with batch execution:</p>
<div class="highlight-java"><div class="highlight"><pre><span class="nd">@Batch</span><span class="o">(</span><span class="mi">100</span><span class="o">)</span>
<span class="nd">@HashPartition</span><span class="o">(</span><span class="s">&quot;wordHash&quot;</span><span class="o">)</span>
<span class="nd">@ProcessInput</span><span class="o">(</span><span class="s">&quot;wordOut&quot;</span><span class="o">)</span>
<span class="kd">public</span> <span class="kt">void</span> <span class="nf">process</span><span class="o">(</span><span class="n">Iterator</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">words</span><span class="o">)</span> <span class="o">{</span>
   <span class="o">...</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="queues">
<h2>Queues<a class="headerlink" href="#queues" title="Permalink to this headline">¶</a></h2>
<p>The data flows between Flowlets are implemented through Queues. In the Standalone Mode,
this is implemented through in-memory data structures. In Distributed Mode, it is
implemented using HBase Tables. This provides reliability and fault-tolerance to the Flow
system such that when a Flowlet instances dies, it is respawned and it starts reading
from the next event in the queue.</p>
</div>
<div class="section" id="flow-transaction-system">
<h2>Flow Transaction System<a class="headerlink" href="#flow-transaction-system" title="Permalink to this headline">¶</a></h2>
<div class="section" id="the-need-for-transactions">
<h3>The Need for Transactions<a class="headerlink" href="#the-need-for-transactions" title="Permalink to this headline">¶</a></h3>
<p>A Flowlet processes the data objects received on its inputs one at a time. While processing
a single input object, all operations, including the removal of the data from the input,
and emission of data to the outputs, are executed in a <strong>transaction</strong>. This provides us
with ACID—atomicity, consistency, isolation, and durability properties:</p>
<ul class="simple">
<li>The process method runs under read isolation to ensure that it does not see dirty writes
(uncommitted writes from concurrent processing) in any of its reads.
It does see, however, its own writes.</li>
<li>A failed attempt to process an input object leaves the data in a consistent state;
it does not leave partial writes behind.</li>
<li>All writes and emission of data are committed atomically;
either all of them or none of them are persisted.</li>
<li>After processing completes successfully, all its writes are persisted in a durable way.</li>
</ul>
<p>In case of failure, the state of the data is unchanged and processing of the input
object can be reattempted. This ensures &#8220;exactly-once&#8221; processing of each object.</p>
</div>
<div class="section" id="occ-optimistic-concurrency-control">
<h3>OCC: Optimistic Concurrency Control<a class="headerlink" href="#occ-optimistic-concurrency-control" title="Permalink to this headline">¶</a></h3>
<p>Tigon uses <em>Optimistic Concurrency Control</em> (OCC) to implement
transactions. Unlike most relational databases that use locks to prevent conflicting
operations between transactions, under OCC we allow these conflicting writes to happen.
When the transaction is committed, we can detect whether it has any conflicts: namely, if
during the lifetime of the transaction, another transaction committed a write for one of
the same keys that the transaction has written. In that case, the transaction is aborted
and all of its writes are rolled back.</p>
<p>In other words: If two overlapping transactions modify the same row, then the transaction
that commits first will succeed, but the transaction that commits last is rolled back due
to a write conflict.</p>
<p>Optimistic Concurrency Control is lockless and therefore avoids problems such as idle
processes waiting for locks, or even worse, deadlocks. However, it comes at the cost of
rollback in case of write conflicts. We can only achieve high throughput with OCC if the
number of conflicts is small. It is therefore a good practice to reduce the probability of
conflicts wherever possible.</p>
<p>Here are some rules to follow for Flows, Flowlets and Procedures:</p>
<ul class="simple">
<li>Keep transactions short. Tigon attempts to delay the beginning of each
transaction as long as possible. For instance, if your Flowlet only performs write
operations, but no read operations, then all writes are deferred until the process
method returns. They are then performed and transacted, together with the
removal of the processed object from the input, in a single batch execution.
This minimizes the duration of the transaction.</li>
<li>However, if your Flowlet performs a read, then the transaction must
begin at the time of the read. If your Flowlet performs long-running
computations after that read, then the transaction runs longer, too,
and the risk of conflicts increases. It is therefore a good practice
to perform reads as late in the process method as possible.</li>
<li>There are two ways to perform an increment: As a write operation that
returns nothing, or as a read-write operation that returns the incremented
value. If you perform the read-write operation, then that forces the
transaction to begin, and the chance of conflict increases. Unless you
depend on that return value, you should always perform an increment
only as a write operation.</li>
<li>Use hash-based partitioning for the inputs of highly concurrent Flowlets
that perform writes. This helps reduce concurrent writes to the same
key from different instances of the Flowlet.</li>
</ul>
<p>Keeping these guidelines in mind will help you write more efficient and faster-performing
code.</p>
</div>
<div class="section" id="writing-to-hbase-transactionally-from-a-flowlet">
<h3>Writing to HBase Transactionally From a Flowlet<a class="headerlink" href="#writing-to-hbase-transactionally-from-a-flowlet" title="Permalink to this headline">¶</a></h3>
<p>Tigon internally uses Tephra extensively to complete transactional operations. Tephra can
also be leveraged by developers to write to HBase transactionally, and in so doing obtain
Tephra&#8217;s ACID properties of transactions. To do this, wrap an
<em>HTable</em> instance (the variable <tt class="docutils literal"><span class="pre">htable</span></tt> in the example below) with Tephra’s
<tt class="docutils literal"><span class="pre">TransactionAwareHTable</span></tt> and add it to the Flowlet’s context:</p>
<div class="highlight-java"><div class="highlight"><pre>public static final class TransactionalFlowlet extends AbstractFlowlet {

  private OutputEmitter&lt;Integer&gt; intEmitter;
  private int i = 0;

  @Override
  public void initialize(FlowletContext context) throws Exception {
    // Acquire HTable instance
    TransactionAwareHTable txAwareHTable = new TransactionAwareHTable(htable);
    context.addTransactionAware(txAwareHTable);
  }

  @Tick(delay = 1L, unit = TimeUnit.SECONDS)
  public void process() throws Exception {
    Put put = new Put(Bytes.toBytes(“testRow”));
    put.add(Bytes.toBytes(“testFamily”), Bytes.toBytes(“testQualifier”), Bytes.toBytes(i));
    transactionAwareHTable.put(put);

    Integer value = ++i;
    intEmitter.emit(value, &quot;integer&quot;, value.hashCode());
  }
}
</pre></div>
</div>
<p>Operations performed on the <tt class="docutils literal"><span class="pre">TransactionAwareHTable</span></tt> instance inside  the <tt class="docutils literal"><span class="pre">initialize</span></tt>, <tt class="docutils literal"><span class="pre">destroy</span></tt>,
and each of the <tt class="docutils literal"><span class="pre">process</span></tt> methods are committed as a single transaction. Exceptions thrown in any
of these methods will result in a rollback of the entire transaction.</p>
</div>
</div>
<div class="section" id="using-tigonsql">
<h2>Using TigonSQL<a class="headerlink" href="#using-tigonsql" title="Permalink to this headline">¶</a></h2>
<p>TigonSQL provides an in-memory SQL streaming engine and can perform filtering,
aggregation, and joins of Streams. This can be highly useful for use cases where a large
ingestion rate is required.</p>
<p>However, it must be noted that the data in TigonSQL is held in-memory and thus there is a
possibility of data loss if the Flowlet container or the Stream Engine fails. The
transaction guarantees and the persistence of data comes into play only after the results
of the <tt class="docutils literal"><span class="pre">AbstractInputFlowlet</span></tt> is emitted and is persisted in HBase Tables through
Queues. A further consideration is that in the current implementation, the instance count
of <tt class="docutils literal"><span class="pre">AbstractInputFlowlet</span></tt> is limited to a single instance.</p>
<p>In order to use the TigonSQL library in your flow, you need a Flowlet that extends
<tt class="docutils literal"><span class="pre">AbstractInputFlowlet</span></tt>. To use the StreamEngine, implement the <tt class="docutils literal"><span class="pre">create</span> <span class="pre">method</span></tt>. The
building blocks of the StreamEngine are the <tt class="docutils literal"><span class="pre">StreamSchema</span></tt> objects, and the
<tt class="docutils literal"><span class="pre">addJSONInput</span></tt> and <tt class="docutils literal"><span class="pre">addQuery</span></tt> methods.</p>
<p><tt class="docutils literal"><span class="pre">StreamSchema</span></tt> objects are constructed using the <tt class="docutils literal"><span class="pre">StreamSchema</span></tt> Builder. These objects
represent the input schema of a Stream, with these fields allowed to be part of the input
schema:</p>
<ul class="simple">
<li>BOOL</li>
<li>INT</li>
<li>LONG</li>
<li>DOUBLE</li>
<li>STRING</li>
</ul>
<p>The Builder’s <tt class="docutils literal"><span class="pre">addField</span></tt> method takes the name of the field, the field type and the
<tt class="docutils literal"><span class="pre">SlidingWindowAttribute</span></tt>. The sliding window attribute is used to annotate that a field is
monotonically increasing or decreasing. A field with this attribute set to
increasing or decreasing might be required for certain SQL queries; for example, &#8220;GROUP BY
<em>increasingField</em>&#8221;.</p>
<p>Once one or more <tt class="docutils literal"><span class="pre">StreamSchemas</span></tt> are created, they are added as an input using the
<tt class="docutils literal"><span class="pre">addJSONInput</span></tt> method. This method takes the name of the input stream and the schema of
the stream. Once the inputs streams have been added, one or more SQL queries can be
defined using an <tt class="docutils literal"><span class="pre">addQuery</span></tt> method. The <tt class="docutils literal"><span class="pre">addQuery</span></tt> method takes the name of the query
and the SQL statement.</p>
<p>The output of the SQL queries will be POJOs, whose output class you can define.
The names of the members of the output class should match the names used in the SQL query
statement. In the example given below, <tt class="docutils literal"><span class="pre">DataPacket</span></tt> is one such POJO class.</p>
<p>In order to process the output of SQL queries, you&#8217;ll need to annotate the methods
with <tt class="docutils literal"><span class="pre">&#64;QueryOutput(&lt;QueryName&gt;)</span></tt>. You can then choose to process the objects in
that method or emit the object to a subsequent Flowlet. In the example given below,
<tt class="docutils literal"><span class="pre">emitData</span></tt> is a method which is annotated with <tt class="docutils literal"><span class="pre">QueryOutput</span></tt> and it emits the
<tt class="docutils literal"><span class="pre">DataPacket</span></tt> object to the next Flowlet:</p>
<div class="highlight-java"><div class="highlight"><pre><span class="kd">public</span> <span class="kd">class</span> <span class="nc">SQLFlowlet</span> <span class="kd">extends</span> <span class="n">AbstractInputFlowlet</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="n">OutputEmitter</span><span class="o">&lt;</span><span class="n">DataPacket</span><span class="o">&gt;</span> <span class="n">dataEmitter</span><span class="o">;</span>
    <span class="kd">private</span> <span class="kd">final</span> <span class="n">Logger</span> <span class="n">LOG</span> <span class="o">=</span> <span class="n">LoggerFactory</span><span class="o">.</span><span class="na">getLogger</span><span class="o">(</span><span class="n">SQLFlowlet</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>

    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">create</span><span class="o">()</span> <span class="o">{</span>
      <span class="n">setName</span><span class="o">(</span><span class="s">&quot;Summation&quot;</span><span class="o">);</span>
      <span class="n">setDescription</span><span class="o">(</span><span class="s">&quot;Sums up the input value over a timewindow&quot;</span><span class="o">);</span>
      <span class="n">StreamSchema</span> <span class="n">schema</span> <span class="o">=</span> <span class="k">new</span> <span class="n">StreamSchema</span><span class="o">.</span><span class="na">Builder</span><span class="o">()</span>
        <span class="o">.</span><span class="na">addField</span><span class="o">(</span><span class="s">&quot;timestamp&quot;</span><span class="o">,</span> <span class="n">GDATFieldType</span><span class="o">.</span><span class="na">LONG</span><span class="o">,</span> <span class="n">GDATSlidingWindowAttribute</span><span class="o">.</span><span class="na">INCREASING</span><span class="o">)</span>
        <span class="o">.</span><span class="na">addField</span><span class="o">(</span><span class="s">&quot;intStream&quot;</span><span class="o">,</span> <span class="n">GDATFieldType</span><span class="o">.</span><span class="na">INT</span><span class="o">)</span>
        <span class="o">.</span><span class="na">build</span><span class="o">();</span>
      <span class="n">addJSONInput</span><span class="o">(</span><span class="s">&quot;intInput&quot;</span><span class="o">,</span> <span class="n">schema</span><span class="o">);</span>
      <span class="n">addQuery</span><span class="o">(</span><span class="s">&quot;sumOut&quot;</span><span class="o">,</span> <span class="s">&quot;SELECT timestamp, SUM(intStream) AS sumValue FROM intInput GROUP BY timestamp&quot;</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="nd">@QueryOutput</span><span class="o">(</span><span class="s">&quot;sumOut&quot;</span><span class="o">)</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">emitData</span><span class="o">(</span><span class="n">DataPacket</span> <span class="n">dataPacket</span><span class="o">)</span> <span class="o">{</span>
      <span class="n">LOG</span><span class="o">.</span><span class="na">info</span><span class="o">(</span><span class="s">&quot;Emitting data to next flowlet&quot;</span><span class="o">);</span>
      <span class="c1">// Each data packet is forwarded to the next flowlet</span>
      <span class="n">dataEmitter</span><span class="o">.</span><span class="na">emit</span><span class="o">(</span><span class="n">dataPacket</span><span class="o">);</span>
    <span class="o">}</span>
  <span class="o">}</span>

<span class="kd">class</span> <span class="nc">DataPacket</span> <span class="o">{</span>
    <span class="c1">// Using the same data type and variable name as specified in the query output</span>
    <span class="kt">long</span> <span class="n">timestamp</span><span class="o">;</span>
    <span class="kt">int</span> <span class="n">sumValue</span><span class="o">;</span>
<span class="o">}</span>
</pre></div>
</div>
<div class="section" id="ingesting-data-into-an-abstractinputflowlet">
<span id="ingesting"></span><h3>Ingesting Data into an AbstractInputFlowlet<a class="headerlink" href="#ingesting-data-into-an-abstractinputflowlet" title="Permalink to this headline">¶</a></h3>
<p>In order to ingest data into the flowlet, the AbstractInputFlowlet gives two
options. One is a HTTP ingestion endpoint; the other is a TCP endpoint. If you run
the Flow in Standalone Mode, the ingestion endpoints are printed out in the log messages
on the console (wrapped for formatting):</p>
<div class="highlight-java"><div class="highlight"><pre>2014-10-02 16:54:40,401 - INFO  [executor-13:c.c.t.s.f.AbstractInputFlowlet@322]
  - Announced Data Port tcpPort_intInput - 63537
2014-10-02 16:54:40,402 - INFO  [executor-13:c.c.t.s.f.AbstractInputFlowlet@322]
  - Announced Data Port httpPort - 63541
</pre></div>
</div>
<p>You can ingest data through the HTTP Port using a curl command such as:</p>
<div class="highlight-java"><div class="highlight"><pre><span class="n">curl</span> <span class="o">-</span><span class="n">v</span> <span class="o">-</span><span class="n">X</span> <span class="n">POST</span> <span class="nl">http:</span><span class="c1">//localhost:&lt;port&gt;/v1/tigon/&lt;InputName&gt; -d &#39;{ &quot;data&quot; : [ “12495”, “233“ ] }’</span>
</pre></div>
</div>
<p>For the example given above, it would then be:</p>
<div class="highlight-java"><div class="highlight"><pre><span class="n">curl</span> <span class="o">-</span><span class="n">v</span> <span class="o">-</span><span class="n">X</span> <span class="n">POST</span> <span class="nl">http:</span><span class="c1">//localhost:63541/v1/tigon/intInput -d &#39;{ &quot;data&quot; : [ “12495”, “233“ ] }’</span>
</pre></div>
</div>
<p>You can choose to ingest data through either HTTP or TCP endpoints; in the case above, the TCP server is
running on 63537. There is one TCP endpoint for each input stream.</p>
<p>If the Flow is running in Distributed Mode on a cluster, you can use the <tt class="docutils literal"><span class="pre">serviceinfo</span></tt>
and <tt class="docutils literal"><span class="pre">discover</span></tt> commands to find out the endpoints.</p>
<p>In the above example, if we execute <tt class="docutils literal"><span class="pre">serviceinfo</span> <span class="pre">&lt;flow-name&gt;</span></tt> as described in the
<a class="reference internal" href="tools.html"><em>Distributed Command-Line Intreface,</em></a> we should see a list of available services:</p>
<div class="highlight-java"><div class="highlight"><pre><span class="n">httpPort</span>
<span class="n">tcpPort_intInput</span>
</pre></div>
</div>
<p>Now we can discover a specific service’s endpoint (either HTTP or TCP) by executing:</p>
<div class="highlight-java"><div class="highlight"><pre><span class="n">discover</span> <span class="o">&lt;</span><span class="n">flow</span><span class="o">-</span><span class="n">name</span><span class="o">&gt;</span> <span class="n">httpPort</span>
</pre></div>
</div>
<p>or:</p>
<div class="highlight-java"><div class="highlight"><pre><span class="n">discover</span> <span class="o">&lt;</span><span class="n">flow</span><span class="o">-</span><span class="n">name</span><span class="o">&gt;</span> <span class="n">tcpPort_intInput</span>
</pre></div>
</div>
<p>This is will display the hostname and port on which those services are running.</p>
<p>Optionally, you can provide a runtime arg when you start (<tt class="docutils literal"><span class="pre">--httpPort=1433</span></tt>) to give a
port number for the HTTP service. The <tt class="docutils literal"><span class="pre">AbstractInputFlowlet</span></tt> will attempt to start the
HTTP server on that port; it will fail if it can’t bind to that port. This option may be
useful only in Standalone Mode; in Distributed Mode, you might also need to know the
hostname where the service is running.</p>
</div>
<div class="section" id="tigonsql-the-query-language">
<h3>TigonSQL, The Query Language<a class="headerlink" href="#tigonsql-the-query-language" title="Permalink to this headline">¶</a></h3>
<p>TigonSQL refers both to a library (the In-memory Stream Processing engine
that can perform filtering, aggregation, and joins of data streams) and the language used
by that library.</p>
<p>The Tigon query language, <em>TigonSQL</em>, is a pure stream query language with a SQL-like
syntax (being mostly a restriction of SQL).</p>
<p><em>TigonSQL</em> is presented in the <a class="reference external" href="architecture#stream-query-language">Tigon Architecture Guide</a>, including the basic concepts with examples.</p>
<p>Details of the language, its theory of operation, quick start guide and complete
reference can be found in the <a class="reference external" href="_downloads/Tigon_SQL_User_Manual_2014_v4.pdf">Tigon SQL User Manual</a>.</p>
<p>For developers who are writing extensions to Tigon SQL, please refer to the
<a class="reference external" href="_downloads/Tigon_SQL_Contributor_Manual_2014_v2.pdf">Tigon SQL Contributor Manual</a>.</p>
</div>
</div>
<div class="section" id="best-practices-for-developing-applications">
<h2>Best Practices for Developing Applications<a class="headerlink" href="#best-practices-for-developing-applications" title="Permalink to this headline">¶</a></h2>
<div class="section" id="initializing-instance-fields">
<h3>Initializing Instance Fields<a class="headerlink" href="#initializing-instance-fields" title="Permalink to this headline">¶</a></h3>
<p>There are three ways to initialize instance fields used in Flowlets:</p>
<ol class="arabic simple">
<li>Using the default constructor;</li>
<li>Using the <tt class="docutils literal"><span class="pre">initialize()</span></tt> method of the Flowlets; and</li>
<li>Using <tt class="docutils literal"><span class="pre">&#64;Property</span></tt> annotations.</li>
</ol>
<p>To initialize using an Property annotation, simply annotate the field definition with
<tt class="docutils literal"><span class="pre">&#64;Property</span></tt>.</p>
<p>The following example demonstrates the convenience of using <tt class="docutils literal"><span class="pre">&#64;Property</span></tt> in a
<tt class="docutils literal"><span class="pre">WordFilter</span></tt> flowlet
that filters out specific words:</p>
<div class="highlight-java"><div class="highlight"><pre><span class="kd">public</span> <span class="kd">static</span> <span class="kd">class</span> <span class="nc">WordFilter</span> <span class="kd">extends</span> <span class="n">AbstractFlowlet</span> <span class="o">{</span>

  <span class="kd">private</span> <span class="n">OutputEmitter</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">out</span><span class="o">;</span>

  <span class="nd">@Property</span>
  <span class="kd">private</span> <span class="kd">final</span> <span class="n">String</span> <span class="n">toFilterOut</span><span class="o">;</span>

  <span class="kd">public</span> <span class="nf">CountByField</span><span class="o">(</span><span class="n">String</span> <span class="n">toFilterOut</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">this</span><span class="o">.</span><span class="na">toFilterOut</span> <span class="o">=</span> <span class="n">toFilterOut</span><span class="o">;</span>
  <span class="o">}</span>

  <span class="nd">@ProcessInput</span><span class="o">()</span>
  <span class="kd">public</span> <span class="kt">void</span> <span class="nf">process</span><span class="o">(</span><span class="n">String</span> <span class="n">word</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(!</span><span class="n">toFilterOut</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="n">word</span><span class="o">))</span> <span class="o">{</span>
      <span class="n">out</span><span class="o">.</span><span class="na">emit</span><span class="o">(</span><span class="n">word</span><span class="o">);</span>
    <span class="o">}</span>
  <span class="o">}</span>
<span class="o">}</span>
</pre></div>
</div>
<p>The Flowlet constructor is called with the parameter when the Flow is configured:</p>
<div class="highlight-java"><div class="highlight"><pre><span class="kd">public</span> <span class="kd">static</span> <span class="kd">class</span> <span class="nc">WordCountFlow</span> <span class="kd">implements</span> <span class="n">Flow</span> <span class="o">{</span>
  <span class="nd">@Override</span>
  <span class="kd">public</span> <span class="n">FlowSpecification</span> <span class="nf">configure</span><span class="o">()</span> <span class="o">{</span>
    <span class="k">return</span> <span class="n">FlowSpecification</span><span class="o">.</span><span class="na">Builder</span><span class="o">.</span><span class="na">with</span><span class="o">()</span>
      <span class="o">.</span><span class="na">setName</span><span class="o">(</span><span class="s">&quot;WordCountFlow&quot;</span><span class="o">)</span>
      <span class="o">.</span><span class="na">setDescription</span><span class="o">(</span><span class="s">&quot;Flow for counting words&quot;</span><span class="o">)</span>
      <span class="o">.</span><span class="na">withFlowlets</span><span class="o">().</span><span class="na">add</span><span class="o">(</span><span class="k">new</span> <span class="n">Tokenizer</span><span class="o">())</span>
                     <span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="k">new</span> <span class="n">WordsFilter</span><span class="o">(</span><span class="s">&quot;the&quot;</span><span class="o">))</span>
                     <span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="k">new</span> <span class="n">WordsCounter</span><span class="o">())</span>
      <span class="o">.</span><span class="na">connect</span><span class="o">().</span><span class="na">from</span><span class="o">(</span><span class="s">&quot;Tokenizer&quot;</span><span class="o">).</span><span class="na">to</span><span class="o">(</span><span class="s">&quot;WordsFilter&quot;</span><span class="o">)</span>
                <span class="o">.</span><span class="na">from</span><span class="o">(</span><span class="s">&quot;WordsFilter&quot;</span><span class="o">).</span><span class="na">to</span><span class="o">(</span><span class="s">&quot;WordsCounter&quot;</span><span class="o">)</span>
      <span class="o">.</span><span class="na">build</span><span class="o">();</span>
  <span class="o">}</span>
<span class="o">}</span>
</pre></div>
</div>
<p>At run-time, when the Flowlet is started, a value is injected into the <tt class="docutils literal"><span class="pre">toFilterOut</span></tt>
field.</p>
<p>Field types that are supported using the <tt class="docutils literal"><span class="pre">&#64;Property</span></tt> annotation are primitives,
boxed types (e.g. <tt class="docutils literal"><span class="pre">Integer</span></tt>), <tt class="docutils literal"><span class="pre">String</span></tt> and <tt class="docutils literal"><span class="pre">enum</span></tt>.</p>
</div>
</div>
<div class="section" id="where-to-go-next">
<h2>Where to Go Next<a class="headerlink" href="#where-to-go-next" title="Permalink to this headline">¶</a></h2>
<p>Now that you&#8217;re familiar with the components and concepts of Tigon, take a look at:</p>
<ul class="simple">
<li><a class="reference external" href="examples/index.html">Examples</a>, with a series of examples demonstrating Tigon.</li>
</ul>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper"><!--
  Copyright © 2014 Cask Data, Inc.

  Licensed under the Apache License, Version 2.0 (the "License"); you may not
  use this file except in compliance with the License. You may obtain a copy of
  the License at

  http://www.apache.org/licenses/LICENSE-2.0

  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
  WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
  License for the specific language governing permissions and limitations under
  the License.
-->

<h3><a href="table-of-contents.html">Table of Contents</a></h3>
<nav>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="index.html">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="getting-started.html">Getting Started</a></li>
<li class="toctree-l1"><a class="reference internal" href="concepts.html">Concepts and Architecture</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="">Developer Guide</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#tigon-flows">Tigon Flows</a></li>
<li class="toctree-l2"><a class="reference internal" href="#tigon-flowlets">Tigon Flowlets</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#input-context">Input Context</a></li>
<li class="toctree-l3"><a class="reference internal" href="#type-projection">Type Projection</a></li>
<li class="toctree-l3"><a class="reference internal" href="#flowlet-method-and-tick-annotation">Flowlet Method and &#64;Tick Annotation</a></li>
<li class="toctree-l3"><a class="reference internal" href="#connection">Connection</a></li>
<li class="toctree-l3"><a class="reference internal" href="#batch-execution">Batch Execution</a></li>
<li class="toctree-l3"><a class="reference internal" href="#flowlets-and-instances">Flowlets and Instances</a></li>
<li class="toctree-l3"><a class="reference internal" href="#partitioning-strategies">Partitioning Strategies</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#queues">Queues</a></li>
<li class="toctree-l2"><a class="reference internal" href="#flow-transaction-system">Flow Transaction System</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#the-need-for-transactions">The Need for Transactions</a></li>
<li class="toctree-l3"><a class="reference internal" href="#occ-optimistic-concurrency-control">OCC: Optimistic Concurrency Control</a></li>
<li class="toctree-l3"><a class="reference internal" href="#writing-to-hbase-transactionally-from-a-flowlet">Writing to HBase Transactionally From a Flowlet</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#using-tigonsql">Using TigonSQL</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#ingesting-data-into-an-abstractinputflowlet">Ingesting Data into an AbstractInputFlowlet</a></li>
<li class="toctree-l3"><a class="reference internal" href="#tigonsql-the-query-language">TigonSQL, The Query Language</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#best-practices-for-developing-applications">Best Practices for Developing Applications</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#initializing-instance-fields">Initializing Instance Fields</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#where-to-go-next">Where to Go Next</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="examples/index.html">Examples and Applications</a></li>
<li class="toctree-l1"><a class="reference internal" href="apis/index.html">APIs</a></li>
<li class="toctree-l1"><a class="reference internal" href="tools.html">Tools</a></li>
<li class="toctree-l1"><a class="reference internal" href="admin.html">Administration</a></li>
<li class="toctree-l1"><a class="reference internal" href="advanced.html">Advanced Features</a></li>
<li class="toctree-l1"><a class="reference internal" href="licenses.html">Licenses and Copyrights</a></li>
<li class="toctree-l1"><a class="reference internal" href="release-notes.html">Release Notes</a></li>
<li class="toctree-l1"><a class="reference internal" href="faq.html">FAQ</a></li>
</ul>

</nav>
  <h4>Previous Topic</h4>
  <p class="topless"><a href="concepts.html"
                        title="Previous Chapter">Tigon Concepts and Architecture</a></p>
  <h4>Next Topic</h4>
  <p class="topless"><a href="examples/index.html"
                        title="Next Chapter">Tigon Examples and Reference Applications</a></p>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick Search</h3>
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer" role="contentinfo">
        &copy; Copyright 2014 Cask Data, Inc.
    </div>
  </body>
</html>